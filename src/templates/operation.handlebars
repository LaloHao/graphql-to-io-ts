{{#*inline "fragments"}}
{{#if hasFragmentsSpread}}{{#if hasFields}} & {{/if}}{{#each fragmentsSpread}}{{fragmentName}}.Fragment{{#unless @last}} & {{/unless}}{{/each}}{{/if}}{{#if hasInlineFragments}}{{#if hasFields}} & ({{/if}}{{#each inlineFragments}}{{onType}}{{#unless @last}} | {{/unless}}{{/each}}{{#if hasFields}}){{/if}}{{/if}}
{{/inline}}
{{#*inline "iotsFragments"}}
{{#if hasFragmentsSpread}}{{#each fragmentsSpread}}{{fragmentName}}.Fragment{{#unless @last}},{{/unless}}
{{/each}}{{/if}}{{#if hasInlineFragments}}{{#if hasFields}} & ({{/if}}{{#each inlineFragments}}{{onType}}{{#unless @last}} | {{/unless}}{{/each}}{{#if hasFields}}){{/if}}{{/if}}
{{/inline}}

export namespace {{ toPascalCase name }} {
  export type Variables = {
    {{> tsFields variables }}
  }

  /* model types */
  {{#eachBackwards innerModels }}
  export type {{ modelType }} ={{#if hasFields}} {
  {{#unless hasInlineFragments}}
    __typename: '{{ schemaBaseType }}'
  {{else}}
    __typename: {{#each inlineFragments}}{{onType}}["__typename"]{{#unless @last}} | {{/unless}}{{/each}};
  {{/unless}}
    {{> tsFields fields }}
  }{{/if}}{{> fragments this }}
  {{~/eachBackwards}}

  /* operation */
  export type {{ toPascalCase operationType }} = {
    // __typename: '{{ toPascalCase operationType }}'
  {{> tsFields fields }}
  }
  {{> fragments this }}

  /* io-ts */
  export const Variables = {{> iotsFields variables }}

  // model types
  {{#eachBackwards innerModels }}
  export const {{ modelType }} = t.intersection([  
    t.type({ __typename: {{#unless hasInlineFragments}}t.literal('{{
      schemaBaseType
    }}'){{else}}t.union([{{#each inlineFragments}}{{onType}}["__typename"]{{#unless @last}}, {{/unless}}{{/each}}])
  {{/unless}} }),
  {{> iotsFields fields }},
  {{> iotsFragments this }}])
  {{/eachBackwards}}

  // operation
  export const {{ toPascalCase operationType }} = t.intersection([  
    // t.type({ __typename: t.literal('{{ toPascalCase operationType }}') }),
    {{> iotsFields fields }},
    {{> iotsFragments this }}])

  // convenience alias for type agnostic use cases
  export const Operation = {{ toPascalCase operationType }}
  export type Operation = {{ toPascalCase operationType }}

}
